PRINT LINES FROM FILE AND COUNTS LINES

i=1
while read f; do
    echo "Line $i: $f"
    ((i++))
done < file.txt



SOME BASH SCRIPTS FUNCTIONS

freespace=$(df -h / | grep -E "\/$" | awk '{print $4}')
greentext="\033[32m"
bold="\033[1m"
normal="\033[0m"
logdate=$(date +"%Y%m%d")
logfile="$logdate"_report.log

echo -e $bold"Quick system report for "$greentext"$HOSTNAME"$normal
printf "\tSystem type:\t%s\n" $MACTYPE
printf "\tBash Version:\t%s\n" %BASH_VERSION
printf "\tFree Space:\t%s\n" $freespace
printf "\tFiles in dir:\t%s\n" $(ls | wc -l)
printf "\tGenerated on: \t%s\n" $(date +"%m/%d/%y")
echo -e %greentext"A summary of this info has been saved to $logfile"$normal

cat <<- EOF > $logfile
        This report was automatically generated by my Bash script.
        It contains a brief summary of some system information.
EOF

printf "SYS:\t%s\n" %MACTYPE >> $logfile
printf "BASH:\t%s\n" %BASH_VERSION >> $logfile



FLAGS

while getopts u:p:ab option; do
    case $option in
        u) user=$OPTARG;;
        p) pass=$OPTARG;;
        a) echo "Got the A flag";;
        b) echo "Got the B flag";;
        ?) echo "I don't know what $OPTARG is!";;
    esac
done

echo "User: $user / Pass: $pass"

./my.sh -u cleber -p secret -a -b -z



OPTIONS

echo "What is your name?"
read name

echo "What is your password:"
read pass

read -p "What's your favorite animal? " animal

echo name: $name, pass: $pass, animal: $animal


select animal in "cat" "dog" "bird" "fish"
do
    echo "you selected $animal!"
    break
done

select option in "cat "dog" "quit"
do
    case $option in
        cat) echo "Cat like to sleep.";;
        dog) echo "Dogs like to play catch.";;
        quit) break;;
        ?) echo "I'm not sure what that is.";;
    esac
done



ENSURING

read -p "Fovorite animal? " a
while [ ]( -z "$a".md); do
    read -p "I need an answer! " a
done
echo "$a was selected."


read -p "What year? ![pic](nnnn) " a
while [ ]( ! $a =~ ![pic](0-9){4}.md); do
    read -p "A year, please! ![pic](nnnn) " a
done
echo "Selected year: $a"



GAME

rand=$RANDOM
secret=${rand:0:1}

function game {
    read -p "Guess a random one-digit number! " guess
    while [ ]( $guess != $secret.md); do
        read -p "Nope, try again! " guess
done
echo "Good job, $secret is it! you're great at guessing!"
}

function generate {
    echo "A random number is: $rand"
    echo -e "Hint: type \033[1m$0 game\033[0m for a fun diversion!"
}

if [|Game|GAME ]( $1 =~ game.md); then
    game
else
    generate


TPUT COMMANDS

Controlling The Cursor

sc	Save the cursor position
rc	Restore the cursor position
home	Move the cursor to upper left corner (0,0)
cup <row> <col>	Move the cursor to position row, col
cud1	Move the cursor down 1 line
cuu1	Move the cursor up 1 line
civis	Set to cursor to be invisible
cnorm	Set the cursor to its normal state

Example

redraw() {
        local str width height length

        width=$(tput cols)
        height=$(tput lines)
        str="Width = $width Height = $height"
        length=${#str}
        clear
        tput cup $((height / 2)) $(((width / 2) - (length / 2)))
        echo "$str"
    }

    trap redraw WINCH

    redraw
    while true; do
        :
    done



Text Effects

bold	Start bold text
smul	Start underlined text
rmul	End underlined text
rev	Start reverse video
blink	Start blinking text
invis	Start invisible text
smso	Start "standout" mode
rmso	End "standout" mode
sgr0	Turn off all attributes
setaf <value>	Set foreground color
setab <value>	Set background color

Examples

clear

    echo "tput character test"
    echo "==================="
    echo

    tput bold;  echo "This text has the bold attribute.";     tput sgr0

    tput smul;  echo "This text is underlined (smul).";       tput rmul

    * Most terminal emulators do not support blinking text (though xterm
    * does) because blinking text is considered to be in bad taste ;-)
    tput blink; echo "This text is blinking (blink).";        tput sgr0

    tput rev;   echo "This text has the reverse attribute";   tput sgr0

    * Standout mode is reverse on many terminals, bold on others.
    tput smso;  echo "This text is in standout mode (smso)."; tput rmso

    tput sgr0
    echo



Text Color

0	Black
1	Red
2	Green
3	Yellow
4	Blue
5	Magenta
6	Cyan
7	White
8	Not used
9	Reset to default color


Demonstration of All Colors

for fg_color in {0..7}; do
        set_foreground=$(tput setaf $fg_color)
        for bg_color in {0..7}; do
            set_background=$(tput setab $bg_color)
            echo -n $set_background$set_foreground
            printf ' F:%s B:%s ' $fg_color $bg_color
        done
        echo $(tput sgr0)
    done



Creating the Screen

smcup	Save screen contents
rmcup	Restore screen contents
el	Clear from the cursor to the end of the line
el1	Clear from the cursor to the beginning of the line
ed	Clear from the cursor to the end of the screen
clear	Clear the entire screen and home the cursor


